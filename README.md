# Αρχιτεκτονική Προηγμένων Υπολογιστών - Εργαστήριο 2
## Εργαστήριο Β - Ομάδα 6
* Χατζηιορδάνου Ελισσάβετ 8269
* Πετρίδη Βασιλική 8602

### Βήμα 1
Διαδοχική εκτέλεση των benchmarks χρησιμοποιώντας τις παρακάτω εντολές:
```
 ./build/ARM/gem5.opt -d spec_results/specbzip configs/example/se.py --cpu-type=MinorCPU --caches --l2cache -c spec_cpu2006/401.bzip2/src/specbzip -o "spec_cpu2006/401.bzip2/data/input.program 10" -I 100000000
```
```
./build/ARM/gem5.opt -d spec_results/specmcf configs/example/se.py --cpu-type=MinorCPU --caches --l2cache -c spec_cpu2006/429.mcf/src/specmcf -o "spec_cpu2006/429.mcf/data/inp.in" -I 100000000
```
```
./build/ARM/gem5.opt -d spec_results/spechmmer configs/example/se.py --cpu-type=MinorCPU --caches --l2cache -c spec_cpu2006/456.hmmer/src/spechmmer -o "--fixed 0 --mean 325 --num 45000 --sd 200 --seed 0
spec_cpu2006/456.hmmer/data/bombesin.hmm" -I 100000000
```
```
./build/ARM/gem5.opt -d spec_results/specsjeng configs/example/se.py --cpu-type=MinorCPU --caches --l2cache -c spec_cpu2006/458.sjeng/src/specsjeng -o
"spec_cpu2006/458.sjeng/data/test.txt" -I 100000000
```
```
./build/ARM/gem5.opt -d spec_results/speclibm configs/example/se.py --cpu-type=MinorCPU --caches --l2cache -c spec_cpu2006/470.lbm/src/speclibm -o "20 spec_cpu2006/470.lbm/data/lbm.in 0 1 spec_cpu2006/470.lbm/data/100_100_130_cf_a.of" -I 100000000
```
1)
Στο αρχείο spec_results έχουν αποθηκευτεί τα αποτελέσματα των παραπάνω εντολών. Ανατρέχοντας στα αρχεία που προέκυψαν (config.ini, config.json, stats.txt) μπορούμε να δούμε τις βασικές παραμέτρους για τον επεξεργαστή που εξομοιώνει ο gem5 όσον αφορά το υποσύστημα μνήμης.
Πιο συγκεκριμένα:


α)
* system.cpu.committedInsts = ο αριθμός των εντολών που δεσμεύτηκαν από τη CPU
* system.cpu.committedOps = ο αριθμός των micro-operations 
* system.cpu.dcache.replacements = ο αριθμός των block replacements για την L1 Dcache
* system.l2.overall_accesses::total = ο αριθμός των access στην L2 cache

O αριθμός των προσβάσεων στην L2 cache μπορεί να υπολογιστεί και από το σύνολο των αστοχιών στην L1 Dcache και L1 Icache. Παρατηρούμε διαφορά στον αριθμό των Committed Instructions σε σχέση με τον αριθμό των Committed Operations, πιο συγκεκριμένα τα Commited Οps είναι περισσότερα. Αυτό συμβαίνει γιατί ενώ έχουμε ορίσει το όριο των Committed Instructions που πρόκειται να γίνουν, κάποιες από αυτές χρειάζεται να διασπασθούν σε micro-operations . 

|Benchmark|Committed Instructions|Committed Ops|L1 Dcache Block Replacements| L2 cache Accesses|
|:-------:|:--------------------:|:-----------:|:--------------------------:|:----------------:|
|specbzip |100.000.001           |100.196.363  |710.569                     |712.341           |
|specmcf  |100.000.001           |109.431.937  |54.452                      |724.390           |
|spechmmer|100.000.000           |101.102.729  |65.718                      |70.563            |
|specsjeng|100.000.000           |184.174.857  |5.262.377                   |5.264.051         |
|speclibm |100.000.000           |100.003.637  |1.486.955                   |1.488.538         |


2)
Ανοίγοντας το αρχείο stats.txt για κάθε ένα από τα benchmarks βλέπουμε τα εξής:
* sim_seconds = Χρόνος εκτέλεσης
* system.cpu.cpi = CPI (Cycles per Instruction)
* dcache.overall_miss_rate::total = Miss Rate για την L1 Data cache
* icache.overall_miss_rate::total = Miss Rate για την L1 Instruction cache
* l2.overall_miss_rate::total = Miss Rate για την L2 cache

| Benchmark | Χρόνος Εκτέλεσης (s) | CPI       | L1 Data cache MR | L1 Instruction cache MR | L2 cache MR |
| :-------: | :------------------: | :-------: | :--------------: | :---------------------: | :---------: |
| specbzip  | 0.083982             | 1.679650  | 0.014798         | 0.000077                | 0.282163    |
| specmcf   | 0.064955             | 1.299095  | 0.002108         | 0.023612                | 0.055046    |
| spechmmer | 0.059396             | 1.187917  | 0.001637         | 0.000221                | 0.077760    |
| specsjeng | 0.513528             | 10.270554 | 0.121831         | 0.000020                | 0.999972    |
| speclibm  | 0.174671             | 3.493415  | 0.060972         | 0.000094                | 0.999944    |

* Διάγραμμα για Χρόνο Εκτέλεσης



![execution time](https://user-images.githubusercontent.com/73646657/146672641-bd1770da-1ab1-43cb-8c86-422d6d3be01a.png)

* Διάγραμμα για CPI


![cpi](https://user-images.githubusercontent.com/73646657/146672643-0b0abf1c-133d-40fa-a9b1-1bc9f9f95444.png)


* Διάγραμμα για L1 Dcache Miss Rate


![l1d](https://user-images.githubusercontent.com/73646657/146672646-e3d75e17-af97-44a9-a222-44b0aa546180.png)


* Διάγραμμα για L1 Icache Miss Rate


![l1i](https://user-images.githubusercontent.com/73646657/146672647-63ad1532-03e6-4a50-8536-5187133d6265.png)


* Διάγραμμα για L2 cache

![l2](https://user-images.githubusercontent.com/73646657/146672653-42e90d76-be39-40be-8dd4-6443c0669da4.png)


Από τα διαγράμματα φαίνεται ότι ο χρόνος εκτέλεσης, το CPI, το L1 Dcache και το L2 cache έχουν ανάλογες διαβαθμίσεις, ενώ το L1 Instruction cache είναι ανεξάρτητο. Το benchmark specsjeng έχει τον πιο αργό χρόνο εκτέλεσης και CPI που ξεπερνάει κατά πολύ τη μονάδα, ενώ το specmcf έχει το μεγαλύτερο miss rate στην L1 Icache. Τέλος, τα benchmarks specsjeng και speclibm φαίνεται να έχουν σχεδόν 100% ρυθμό αστοχίας, όταν κάνουν access στην L2 cache.

3)
Όπως διαπιστώθηκε και στο προηγούμενο εργαστήριο το default cpu-clock είναι 2GHz. Με το flag -cpu--clock=1.5GHz εκτελούμε ξανά τα benchmarks και ελέγχουμε στα δύο αρχεία stats.txt, που έχουν προκύψει για κάθε benchmark, τις παραμέτρους system.clk_domain.clock και system.cpu_clk_domain.clock. Και στις δύο συχνότητες, η παράμετρος system.clk_domain.clock παραμένει ίδια και ίση με 1000 (Clock period in ticks), ενώ η παράμετρος system.cpu_clk_domain.clock είναι διαφορετική. Στην πρώτη προσομοίωση, που δε χρησιμοποιήθηκε σημαία για τον ορισμό του cpu-clock, βλέπουμε ότι η περίοδος είναι ίση με 500ps και στη δεύτερη είναι 667ps. Συμπεραίνουμε, λοιπόν, ότι η πρώτη παράμετρος αναφέρεται στο ρολόι του συστήματος, το οποίο έχει συχνότητα σταθερή και ίση με 1GHz. Η δεύτερη παράμετρος αναφέρεται στο ρολόι της CPU και γι'αυτό, κατά την πρώτη προσομοίωση που δε χρησιμοποιούμε σημαία, η συχνότητα του είναι ίση με 2GHz (T=500ps), δηλ. ίση με την default, ενώ στη δεύτερη προσομοίωση είναι ίση με 1.5GHz (667ps) όπως ακριβώς θέσαμε.
Στο ίδιο συμπέρασμα καταλήγουμε και ελέγχωντας το αρχείο config.json στο σύστημα με 1.5GHz.

| Benchmark | 2GHz     | 1.5GHz |
|:---------:|:--------:|:------:|
| specbzip  | 0.083962 |0.109754|
| specmcf   | 0.064955 |0.086162|
| spechmmer | 0.059396 |0.079149|
| specsjeng | 0.513528 |0.581937|
| speclibm  | 0.174671 |0.205034|

Καθώς μειώνεται η συχνότητα, αυξάνεται ανάλογα και ο χρόνος εκτέλεσης, εκτός από την περίπτωση των benchmarks specsjeng και speclibm στα οποία δεν αυξήθηκε εξίσου σημαντικά. Συνεπώς, δεν μπορούμε να πούμε ότι έχουμε τέλειο scaling. Αυτό μπορεί να οφείλεται επειδή τα συγκεκριμένα προγράμματα έχουν με διαφορά μεγαλύτερο ρυθμό αστοχίας σε L1 Dcache και L2 cache σε σχέση με τα υπόλοιπα, πράγμα που είναι λογικό να προκαλεί καθυστερήσεις αφού ο επεξεργαστής πρέπει να κάνει access αλλού για να βρει την πληροφορία που ψάχνει. Εικάζουμε πως αν προσθέσουμε έναν ακόμα επεξεργαστή,  ναι μεν θα έχουμε μεγαλύτερη ταχύτητα αλλά όχι διπλάσια. Από ένα σημείο και μετά θα πρέπει να βελτιώσουμε και τα υπόλοιπα στοιχεία, ώστε να έχουμε τέλειο scalling. 

### Βήμα 2
1)
Μέσα από το αρχείο config.ini βλέπουμε τις default τιμές των παραμέτρων που ζητούμαστε να ελέγξουμε και να αλλάξουμε για τη μέγιστη επίδοση:
* L1 Dcache, L1 Icache, L2 cache Associativity: 2, 2, 8 αντίστοιχα
* Block size: 64
* Μέγεθος Cache Line: 64
* L1 Dcache, L1 Icache, L2 cache Size Allocation: 65536, 32768, 2.097.152 αντίστοιχα

Για να δούμε πως η αλλαγή των παραμέτρων αυτών επηρέασε το CPI των benchmarks, εκτελέσαμε κάθε πρόγραμμα ξεχωριστά αλλάζοντας μόνο μία παράμετρο τη φορά. Το εύρος τιμών που χρησιμοποιήθηκε για τη μελέτη είναι το εξής:
* L1 Dcache size: 32, 64, 128
* L1 Icache size: 32, 64, 128
* L2 cache: 512, 2048, 4096
* L1 Associativity: 1, 2, 4, 8
* L2 Associativity: 1, 2, 4, 8
* Cache Line Size: 32, 64, 128

2)
Στο αρχείο graphs2 έχουμε αποθηκεύσει γραφήματα που δείχνουν πως επηρεάζει η κάθε παράμετρος το CPI των benchmarks. Δοκιμάζοντας πληθώρα συνδυασμών και λαμβάνοντας υπόψιν τα σχετικά διαγράμματα, επιλέξαμε τους βέλτιστους συνδυασμούς για CPI όσο το δυνατόν πιο κοντά στη μονάδα (στο βήμα 3 παρατίθενται ακριβώς οι συνδυασμοί μας, οι οποίοι θα οδηγήσουν και σε βέλτιστο κόστος). Μέσω αυτών των συνδυασμών, παρατηρήσαμε ότι κοινός παράγοντας βελτιστοποίησης για όλα τα benchmarks ήταν η αύξηση του μεγέθους cache line, ενώ στα specsjeng και speclibm σημαντικό ρόλο έπαιξε και η αύξηση του μεγέθους των L2 cache και L1 Icache. Επιλογή μεγάλου L1 Dcache size χρειάστηκε στα specbzip, specmcf και spechmmer, καθώς και σχετική αύξηση του associativity και των 2 μνημών.

### Βήμα 3
Από την βιβλιογραφία γνωρίζουμε ότι όσο μεγαλώνει μια μνήμη τόσο αυξάνει και το κόστος της. Στόχος μας είναι να ορίσουμε κάποιες βαρύτητες για τους παράγοντες που χρησιμοποιήσαμε στο δεύτερο βήμα, έτσι ώστε να έχουμε όσο το δυνατόν μικρότερο κόστος και βέλτιστο CPI. Όπως έχει γίνει εμφανές από το δεύτερο βήμα, ο κάθε παράγοντας επηρεάζει το CPI σε διαφορετικό βαθμό. Παρακάτω βλέπουμε πως , αντίστοιχα, αυτοί οι παράγοντες επηρεάζουν το κόστος με βάση τα συμπεράσματα από την μελέτη μας.
Η συνάρτηση του κόστους μας θα έχει μια τέτοια μορφή:
```
Cost = a(L1isize + L1dsize) + β(L1iassoc + L1dassoc) + γ(L2size) + δ(L2assoc) + ε(cache line size)
```
*	**Βαρύτητα α:** Το μέγεθος την μνήμης cache L1 είναι αυτό με το μεγαλύτερο κόστος σε σχέση με τα άλλα στοιχεία. Γι'αυτό και το βάρος που το αντιπροσωπεύει θα πρέπει σχεδόν να ισούται με το άθροισμα των υπολοίπων.
*	**Βαρύτητα β:** Αύξηση του associativity αυξάνει την πολυπλοκότητα και αντίστοιχα το κόστος. Συγκεκριμένα για το associativity της L1, η βαρύτητα του στην συνάρτηση κόστους μας θα είναι μεγάλη, σχεδόν αντίστοιχη της βαρύτητας α.
*	**Βαρύτητα γ και βαρύτητα δ:** Το μέγεθος της μνήμης L2 αν και σημαντικό για την λειτουργία της CPU μας είναι αρκετά μικρότερο από αυτό της L1. Θα ισχύει το αντίστοιχο για το associativity της. Γι'αυτό και αυτά τα δύο βάρη θα αντιπροσωπεύουν περίπου το 1/4 του αθροίσματος όλων των βαρών.
*	**Βαρύτητα ε:** Το μέγεθος της cache line size επηρεάζει το κόστος λιγότερο από όλα τα υπόλοιπα στοιχεία και για αυτό θα έχει την αντίστοιχη βαρύτητα, η οποία θα είναι της τάξης του 5%.
Μετά από τα παραπάνω, η συνάρτησή μας παίρνει την εξής μορφή:
```
Cost = 0.4(L1isize + L1dsize) + 0.3(L1iassoc + L1dassoc) + 0.15(L2size) + 0.1(L2assoc) + 0.05(cache line size)
```

Παρακάτω παραθέτουμε τα κόστη των benchmarks με κάποια στοιχεία, τα οποία έχουμε κρίνει από το βήμα 2 ότι οδηγούν στο βέλτιστο CPI. Εφόσον, το νόμισμά μας δεν είναι πραγματικό έχει νόημα να χρησιμοποιηθεί ώστε να δούμε πόσο πιο ακριβό είναι το ένα μοντέλο σε σχέση με το άλλο όταν βάζουμε τα “ιδανικά” δεδομένα.

| Benchmark | CPI         | Cost     | L1d Cache size | L1i Cache Size | L2 Cache Size | L1 associativity | L2 associativity | Cache line size |
| :-------: | :---------: | :-------:| :------------: | :------------: | :-----------: | :--------------: | :--------------: | :-------------: |
| specbzip  | 1.615699    |  441.6   |  256 kB        | 64  kB         |2048 kB        | 4                | 8                | 64              |
| specmcf   | 1.154912    |  441.6   |  256 kB        | 64  kB         |2048 kB        | 4                | 8                | 64              |
| spechmmer | 1.179978    |  392.4   |  128 kB        | 64  kB         |2048 kB        | 2                | 8                | 128             |
| specsjeng | 6.795293    |  699.6   |  64  kB        | 256 kB         |4096 kB        | 2                | 8                | 128             |
| speclibm  | 2.576597    |  725.2   |  128 kB        | 128 kB         |4096 kB        | 2                | 8                | 128             |



Όπως ήταν αναμενόμενο, τα 3 πρώτα benchmark χρειάζονται το χαμηλότερο κόστος για να πετύχουμε το καλύτερο CPI (κοντά στην μονάδα). Τα δύο τελευταία benchmark έχουν σχεδόν το διπλάσιο κόστος για να πετύχουμε μείωση του CPI. Αν και απαιτεί σημαντική βελτίωση από την αρχική τιμή τους, παραμένει (ειδικά για το sjeng) μακρυά από την μονάδα.
Το συμπέρασμά μας φαίνεται στο παρακάτω διάγραμμα όπου παρατίθενται τα κόστη κάθε benchmark και σημειώνονται τα αντίστοιχα CPI τους:
![benchmark_cost](https://user-images.githubusercontent.com/73646657/146672742-0007c950-3c55-4f56-91da-8459e5bbcc36.png)


## Κριτική:
Η εργασία θα μπορούσε να χαρακτηριστεί ναι μεν απλοϊκή χωρίς ιδιαίτερες δυσκολίες στην κατανόηση, αλλά αρκετά χρονοβόρα λόγω της εκτέλεσης των benchmarks. Παρ'όλα αυτά δόθηκε αρκετός χρόνος για την έγκυρη υλοποίησή τους και με τη χρήση των bash scripts μπορέσαμε να αυτοματοποιήσουμε ένα κομμάτι της διαδικασίας. Γενικότερα, η εργασία μας βοήθησε να κατανοήσουμε καλύτερα τους παράγοντες που μπορούν να επηρεάσουν την επίδοση ενος μετροπρογράμματος. Μεγαλύτερο ενδιάφερον, όμως, μας προξένησε το τρίτο βήμα, καθώς έκανε το πρόβλημα λίγο πιο πρακτικό και με την εισαγωγή του παράγοντα κόστος έφερε την προσομοίωση στον πραγματικό κόσμο. 

Πηγές: Διαφάνειες του Μαθήματος "Αρχιτεκτονική Υπολογιστών" στο elearning, [https://www.gem5.org/], [https://www.spec.org/cpu2006/],  [https://www.extremetech.com/extreme/188776-how-l1-and-l2-cpu-caches-work-and-why-theyre-an-essential-part-of-modern-chips]
